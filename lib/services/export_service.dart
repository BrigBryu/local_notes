import 'dart:io';
import 'dart:isolate';
import 'package:flutter/foundation.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:path_provider/path_provider.dart';
import 'package:path/path.dart' as path;
import 'package:archive/archive.dart';

final exportServiceProvider = Provider<ExportService>((ref) {
  return ExportService();
});

class ExportService {
  Future<File> createZip({required List<dynamic> selectedNotes}) async {
    try {
      if (kDebugMode) {
        print('Exporting ${selectedNotes.length} notes');
      }
      
      // Run heavy I/O operations in isolate
      final zipBytes = await Isolate.run(() => _createZipInIsolate(selectedNotes));
      
      // Get accessible export directory
      final directory = await _getExportDirectory();
      final timestamp = DateTime.now().millisecondsSinceEpoch;
      final fileName = 'local_notes_export_$timestamp.zip';
      final zipFile = File(path.join(directory.path, fileName));
      
      // Ensure directory exists
      await directory.create(recursive: true);
      
      if (kDebugMode) {
        print('Writing ${zipBytes.length} bytes to: ${zipFile.path}');
      }
      
      await zipFile.writeAsBytes(zipBytes);
      
      // Verify file was written
      final exists = await zipFile.exists();
      final fileSize = exists ? await zipFile.length() : 0;
      
      if (kDebugMode) {
        print('Export complete: ${zipFile.path}');
        print('File exists: $exists, Size: $fileSize bytes');
      }
      
      return zipFile;
    } catch (e) {
      if (kDebugMode) {
        print('Export error: $e');
      }
      rethrow;
    }
  }

  static List<int> _createZipInIsolate(List<dynamic> notes) {
    final archive = Archive();
    
    // Add individual note files
    for (final note in notes) {
      final title = _slugifyTitle(note.title);
      final fileName = '$title.txt';
      
      final content = _formatNoteContent(note);
      final file = ArchiveFile(fileName, content.length, content.codeUnits);
      archive.addFile(file);
    }
    
    // Add a summary file
    final summary = _createSummaryContent(notes);
    final summaryFile = ArchiveFile('_export_summary.txt', summary.length, summary.codeUnits);
    archive.addFile(summaryFile);
    
    // Create ZIP
    final zipEncoder = ZipEncoder();
    return zipEncoder.encode(archive)!;
  }

  static String _slugifyTitle(String title) {
    if (title.isEmpty) return 'untitled';
    
    // Replace special characters with underscores
    String slug = title
        .toLowerCase()
        .replaceAll(RegExp(r'[^a-z0-9\s-]'), '')
        .replaceAll(RegExp(r'\s+'), '_')
        .replaceAll(RegExp(r'_+'), '_')
        .replaceAll(RegExp(r'^_|_$'), '');
    
    if (slug.isEmpty) return 'untitled';
    
    // Limit length
    if (slug.length > 50) {
      slug = slug.substring(0, 50);
    }
    
    return slug;
  }

  static String _formatNoteContent(dynamic note) {
    final buffer = StringBuffer();
    
    // Title
    if (note.title.isNotEmpty) {
      buffer.writeln(note.title);
      buffer.writeln('=' * note.title.length);
      buffer.writeln();
    }
    
    // Body
    if (note.body.isNotEmpty) {
      buffer.writeln(note.body);
      buffer.writeln();
    }
    
    // Tags
    if (note.tags != null && (note.tags as List).isNotEmpty) {
      buffer.writeln('Tags: ${(note.tags as List<String>).join(', ')}');
      buffer.writeln();
    }
    
    // Metadata
    buffer.writeln('---');
    buffer.writeln('Created: ${note.createdAt}');
    buffer.writeln('Updated: ${note.updatedAt}');
    if (note.id != null) {
      buffer.writeln('ID: ${note.id}');
    }
    
    return buffer.toString();
  }

  static String _createSummaryContent(List<dynamic> notes) {
    final buffer = StringBuffer();
    final now = DateTime.now();
    
    buffer.writeln('Local Notes Export Summary');
    buffer.writeln('=' * 25);
    buffer.writeln();
    buffer.writeln('Export Date: $now');
    buffer.writeln('Total Notes: ${notes.length}');
    buffer.writeln();
    
    buffer.writeln('Exported Notes:');
    buffer.writeln('-' * 15);
    
    for (int i = 0; i < notes.length; i++) {
      final note = notes[i];
      final title = note.title.isEmpty ? 'Untitled' : note.title;
      buffer.writeln('${i + 1}. $title');
      
      if (note.tags != null && (note.tags as List).isNotEmpty) {
        buffer.writeln('   Tags: ${(note.tags as List<String>).join(', ')}');
      }
      
      if (note.body.isNotEmpty) {
        final preview = note.body.length > 100 
            ? '${note.body.substring(0, 100)}...'
            : note.body;
        buffer.writeln('   Preview: ${preview.replaceAll('\n', ' ')}');
      }
      
      buffer.writeln();
    }
    
    buffer.writeln();
    buffer.writeln('Generated by Local Notes app');
    
    return buffer.toString();
  }

  static Future<Directory> _getExportDirectory() async {
    // Use app's documents directory - guaranteed to work and accessible via Files app
    final documentsDir = await getApplicationDocumentsDirectory();
    final exportDir = Directory(path.join(documentsDir.path, 'exports'));
    
    if (kDebugMode) {
      print('Using app documents directory: ${exportDir.path}');
    }
    
    return exportDir;
  }

  static Future<bool> _canCreateDirectory(Directory dir) async {
    try {
      await dir.create(recursive: true);
      return true;
    } catch (e) {
      return false;
    }
  }
}